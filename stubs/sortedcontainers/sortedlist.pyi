# flake8: noqa
# Stubs for sortedcontainers.sortedlist (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import MutableSequence
from typing import Any, Optional, Union, Tuple, TypeVar, Iterable, Iterator, Sequence, ClassVar, Callable, overload

_T = TypeVar('_T')

def recursive_repr(fillvalue: str = ...): ...

_SL = TypeVar('_SL', bound=SortedList)

class SortedList(MutableSequence[_T]):
    DEFAULT_LOAD_FACTOR: ClassVar[int] = ...
    def __init__(self, iterable: Optional[Iterable[_T]] = ..., key: Optional[str] = ...) -> None: ...
    def __new__(cls, iterable: Optional[Any] = ..., key: Optional[Any] = ...): ...
    @property
    def key(self) -> Any: ...
    def clear(self) -> None: ...
    def add(self, value: _T) -> None: ...
    def update(self, iterable: Iterable[_T]) -> None: ...
    def __contains__(self, value: object) -> bool: ...
    def discard(self, value: _T) -> None: ...
    def remove(self, value: _T) -> None: ...
    def __delitem__(self, index: Union[int, slice]): ...
    @overload
    def __getitem__(self, index: int) -> _T: ...
    @overload
    def __getitem__(self, index: slice) -> Sequence[_T]: ...
    @overload
    def __setitem__(self, index: int, value: _T) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[_T]) -> None: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __reversed__(self) -> Iterator[_T]: ...
    def reverse(self) -> None: ...
    def islice(self, start: Optional[int] = ..., stop: Optional[int] = ..., reverse: bool = ...) -> Iterator[_T]: ...
    def irange(self, minimum: Optional[_T] = ..., maximum: Optional[_T] = ..., inclusive: Tuple[bool, bool] = ..., reverse: bool = ...) -> Iterator[_T]: ...
    def __len__(self) -> int: ...
    def bisect_left(self, value: _T) -> int: ...
    def bisect_right(self, value: _T) -> int: ...
    def bisect(self, value: _T) -> int: ...
    def count(self, value: _T) -> int: ...
    def copy(self: _SL) -> _SL: ...
    def __copy__(self: _SL) -> _SL: ...
    def append(self, value: _T) -> None: ...
    def extend(self, values: Iterable[_T]) -> None: ...
    def insert(self, index: int, value: _T) -> None: ...
    def pop(self, index: int = ...) -> _T: ...
    def index(self, value: _T, start: Optional[int] = ..., stop: Optional[int] = ...) -> int: ...
    def __add__(self: _SL, other: Iterable[_T]) -> _SL: ...
    def __radd__(self: _SL, other: Iterable[_T]) -> _SL: ...
    def __iadd__(self: _SL, other: Iterable[_T]) -> _SL: ...
    def __mul__(self: _SL, num: int) -> _SL: ...
    def __rmul__(self: _SL, num: int) -> _SL: ...
    def __imul__(self: _SL, num: int) -> _SL: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...

def identity(value: _T) -> _T: ...

class SortedKeyList(SortedList[_T]):
    def __init__(self, iterable: Optional[Iterable[_T]] = ..., key: Callable[[_T], Any] = ...) -> None: ...
    def __new__(cls, iterable: Optional[Iterable[_T]] = ..., key: Callable[[_T], Any] = ...): ...
    @property
    def key(self) -> Callable[[_T], Any]: ...
    def irange_key(self, min_key: Optional[Any] = ..., max_key: Optional[Any] = ..., inclusive: Tuple[bool, bool] = ..., reverse: bool = ...): ...
    def bisect_key_left(self, key: Any) -> int: ...
    def bisect_key_right(self, key: Any) -> int: ...
    def bisect_key(self, key: Any) -> int: ...
SortedListWithKey = SortedKeyList
